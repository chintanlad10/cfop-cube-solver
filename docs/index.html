<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Rubik's Cube Solver</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                height: 100vh;
                overflow: hidden;
            }
            
            .three-container {
                position: relative;
                width: 100vw;
                height: 100vh;
            }
            
            #three {
                width: 100%;
                height: 100%;
            }
            
            .controls {
                position: absolute;
                top: 20px;
                left: 20px;
                z-index: 100;
                display: flex;
                gap: 15px;
            }
            
            button {
                background: rgba(255, 255, 255, 0.9);
                border: none;
                padding: 12px 24px;
                border-radius: 25px;
                font-weight: bold;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.3s ease;
                backdrop-filter: blur(10px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }
            
            button:hover {
                background: white;
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            }
            
            #solve-button {
                background: rgba(76, 175, 80, 0.9);
                color: white;
            }
            
            #solve-button:hover {
                background: #4CAF50;
            }
        </style>
    </head>
    <body>
        <div class="three-container">
            <div class="controls">
                <button id="solve-button">ðŸ”„ SOLVE</button>
                <button id="scramble-button">ðŸŽ² SCRAMBLE</button>
            </div>
            <div id="three"></div>
        </div>
        <script type="module">
            import * as THREE from "https://unpkg.com/three@0.124.0/build/three.module.js";
            import { OrbitControls } from "./js/three/OrbitControls.js";

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            // Camera setup
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 4, 6);

            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('three').appendChild(renderer.domElement);

            // Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 5;
            controls.maxDistance = 15;
            controls.enablePan = false;
            controls.update();

            // Create cube geometry and materials
            const cubeSize = 0.95;
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            
            // Cube colors (standard Rubik's cube colors)
            const colors = {
                white: 0xffffff,
                red: 0xff0000,
                blue: 0x0000ff,
                orange: 0xff8c00,
                green: 0x00ff00,
                yellow: 0xffff00,
                black: 0x000000
            };

            // Create materials
            const materials = Object.values(colors).map(color => 
                new THREE.MeshLambertMaterial({ color })
            );

            // Create 3x3x3 cube (27 total, but we'll skip the center)
            const cubes = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue; // Skip center

                        const cube = new THREE.Mesh(geometry, materials[6]); // Black base
                        cube.position.set(x * 1.05, y * 1.05, z * 1.05);
                        
                        // Add colored faces based on position
                        const faceGeometry = new THREE.PlaneGeometry(0.9, 0.9);
                        
                        // Add stickers based on position
                        if (x === -1) { // Left face - Green
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.green }));
                            sticker.position.set(-0.501, 0, 0);
                            sticker.rotation.y = Math.PI / 2;
                            cube.add(sticker);
                        }
                        if (x === 1) { // Right face - Blue  
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.blue }));
                            sticker.position.set(0.501, 0, 0);
                            sticker.rotation.y = -Math.PI / 2;
                            cube.add(sticker);
                        }
                        if (y === 1) { // Top face - White
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.white }));
                            sticker.position.set(0, 0.501, 0);
                            sticker.rotation.x = -Math.PI / 2;
                            cube.add(sticker);
                        }
                        if (y === -1) { // Bottom face - Yellow
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.yellow }));
                            sticker.position.set(0, -0.501, 0);
                            sticker.rotation.x = Math.PI / 2;
                            cube.add(sticker);
                        }
                        if (z === 1) { // Front face - Red
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.red }));
                            sticker.position.set(0, 0, 0.501);
                            cube.add(sticker);
                        }
                        if (z === -1) { // Back face - Orange
                            const sticker = new THREE.Mesh(faceGeometry, new THREE.MeshLambertMaterial({ color: colors.orange }));
                            sticker.position.set(0, 0, -0.501);
                            sticker.rotation.y = Math.PI;
                            cube.add(sticker);
                        }

                        scene.add(cube);
                        cubes.push(cube);
                    }
                }
            }

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Simple scramble function
            function scrambleCube() {
                cubes.forEach((cube, index) => {
                    // Random rotation
                    cube.rotation.x = (Math.random() - 0.5) * 0.3;
                    cube.rotation.y = (Math.random() - 0.5) * 0.3;
                    cube.rotation.z = (Math.random() - 0.5) * 0.3;
                    
                    // Slight position variation
                    const baseX = ((index % 3) - 1) * 1.05;
                    const baseY = (Math.floor((index % 9) / 3) - 1) * 1.05;
                    const baseZ = (Math.floor(index / 9) - 1) * 1.05;
                    
                    cube.position.set(
                        baseX + (Math.random() - 0.5) * 0.1,
                        baseY + (Math.random() - 0.5) * 0.1,
                        baseZ + (Math.random() - 0.5) * 0.1
                    );
                });
            }

            // Reset cube to solved state
            function solveCube() {
                let index = 0;
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            if (x === 0 && y === 0 && z === 0) continue;
                            
                            if (cubes[index]) {
                                cubes[index].position.set(x * 1.05, y * 1.05, z * 1.05);
                                cubes[index].rotation.set(0, 0, 0);
                                index++;
                            }
                        }
                    }
                }
            }

            // Button event listeners
            document.getElementById('solve-button').addEventListener('click', solveCube);
            document.getElementById('scramble-button').addEventListener('click', scrambleCube);

            // Handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        </script>
    </body>
</html>
